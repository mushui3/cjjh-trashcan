<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>GPU 炸裂啟動器</title>
<style>
  body, html {
    margin:0; padding:0; background:#000; color:#fff; font-family: monospace;
    display:flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh;
  }
  canvas { display:none; }
  input, button {
    font-size: 1.2em;
    margin: 0.5em;
    padding: 0.5em 1em;
    border-radius: 8px;
    border: none;
  }
  input {
    width: 120px;
    text-align: center;
  }
  button {
    background:#ff3366; cursor:pointer; color:#fff; transition: background 0.3s;
  }
  button:hover:not(:disabled) {
    background:#ff6699;
  }
  button:disabled {
    background:#555;
    cursor: not-allowed;
  }
</style>
</head>
<body>

<label for="trianglesInput">三角形數量 (1000 ~ 100000): </label>
<input type="number" id="trianglesInput" min="1000" max="100000" step="1000" value="50000" />
<button id="startBtn">炸</button>
<canvas id="glcanvas"></canvas>

<script>
const canvas = document.getElementById('glcanvas');
const btn = document.getElementById('startBtn');
const input = document.getElementById('trianglesInput');
let animationId = null;

btn.addEventListener('click', () => {
  const numTriangles = parseInt(input.value, 10);
  if (isNaN(numTriangles) || numTriangles < 1000 || numTriangles > 100000) {
    alert('數量限制在 1000 ~ 100000 之間，且必須是數字');
    return;
  }

  btn.disabled = true;
  input.disabled = true;

  btn.style.display = 'none';
  input.style.display = 'none';
  canvas.style.display = 'block';

  startGpuBlast(numTriangles);
});

function startGpuBlast(numTriangles) {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  const gl = canvas.getContext('webgl');
  if (!gl) {
    alert('你的瀏覽器不支援 WebGL，沒辦法炸 GPU。');
    return;
  }

  gl.viewport(0, 0, canvas.width, canvas.height);

  const vsSource = `
    attribute vec4 aVertexPosition;
    uniform float uTime;
    void main(void) {
      float angle = uTime + aVertexPosition.x * 10.0;
      gl_Position = vec4(
        aVertexPosition.x,
        aVertexPosition.y + sin(angle) * 0.1,
        aVertexPosition.z,
        1.0
      );
    }
  `;

  const fsSource = `
    precision mediump float;
    void main(void) {
      gl_FragColor = vec4(0.8, 0.1, 0.5, 1.0);
    }
  `;

  function loadShader(type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      alert('Shader 編譯錯誤: ' + gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }

  const vertexShader = loadShader(gl.VERTEX_SHADER, vsSource);
  const fragmentShader = loadShader(gl.FRAGMENT_SHADER, fsSource);

  const shaderProgram = gl.createProgram();
  gl.attachShader(shaderProgram, vertexShader);
  gl.attachShader(shaderProgram, fragmentShader);
  gl.linkProgram(shaderProgram);

  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
    alert('Shader 程式連結失敗: ' + gl.getProgramInfoLog(shaderProgram));
    return;
  }

  gl.useProgram(shaderProgram);

  const vertexPosition = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
  const uTime = gl.getUniformLocation(shaderProgram, 'uTime');

  const positions = [];

  for(let i = 0; i < numTriangles; i++) {
    for(let j = 0; j < 3; j++) {
      positions.push(Math.random() * 2 - 1);
      positions.push(Math.random() * 2 - 1);
      positions.push(0);
    }
  }

  const positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

  gl.enableVertexAttribArray(vertexPosition);
  gl.vertexAttribPointer(vertexPosition, 3, gl.FLOAT, false, 0, 0);

  function render(time) {
    time *= 0.001;
    gl.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.uniform1f(uTime, time);
    gl.drawArrays(gl.TRIANGLES, 0, numTriangles * 3);
    animationId = requestAnimationFrame(render);
  }

  animationId = requestAnimationFrame(render);
}
</script>
</body>
</html>
