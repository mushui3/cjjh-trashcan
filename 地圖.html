<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç„¡é™åœ°åœ–è£½ä½œå™¨</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            color: #1a202c;
            user-select: none;
            overflow: hidden;
            display: flex;
            flex-direction: row;
        }
        canvas {
            touch-action: none;
            cursor: crosshair;
            background-color: #0077c2; /* æµ·æ´‹èƒŒæ™¯ */
            flex-grow: 1; /* ä½”æ“šå‰©é¤˜ç©ºé–“ */
        }
        .controls-sidebar {
            width: 300px;
            min-width: 250px;
            height: 100vh;
            background-color: white;
            padding: 1.5rem;
            box-shadow: -4px 0 6px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            z-index: 100;
        }
        .controls {
            position: static;
            transform: none;
            width: auto;
            max-width: none;
            box-shadow: none;
            padding: 0;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .control-group {
            display: flex;
            flex-direction: column;
        }
        .control-label {
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 0.5rem;
        }
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type="range"]:hover {
            opacity: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4299e1;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 700;
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
            text-align: center;
        }
        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .land-button {
            background-color: #48bb78;
            color: white;
        }
        .sea-button {
            background-color: #4299e1;
            color: white;
        }
        .road-button {
            background-color: #64748b;
            color: white;
        }
        .building-button {
            background-color: #f9a8d4;
            color: white;
        }
        .clear-button, .export-button {
            background-color: #e53e3e;
            color: white;
        }
        .export-data-button {
            background-color: #5a67d8;
            color: white;
        }
        .export-image-button {
            background-color: #38a169;
            color: white;
        }
        .import-data-button {
            background-color: #4CAF50;
            color: white;
        }
        .mode-active {
            box-shadow: inset 0 0 0 4px #a0aec0;
        }
        .info-panel {
            background-color: white;
            padding: 1rem;
            border-radius: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            text-align: center;
            font-size: 0.875rem;
            color: #4a5568;
            margin-top: auto; /* å°‡å…¶æ¨åˆ°åº•éƒ¨ */
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
            text-align: center;
        }
        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        .building-size-group {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        .building-size-button {
            padding: 0.5rem 1rem;
            border: 2px solid transparent;
            border-radius: 0.5rem;
            cursor: pointer;
            background-color: #cbd5e0;
            color: #4a5568;
            font-weight: 600;
            flex: 1;
            text-align: center;
        }
        .building-size-button.active {
            border-color: #4299e1;
            background-color: #bee3f8;
        }
        .building-orientation-button {
            padding: 0.5rem 1rem;
            border: 2px solid transparent;
            border-radius: 0.5rem;
            cursor: pointer;
            background-color: #cbd5e0;
            color: #4a5568;
            font-weight: 600;
            flex: 1;
            text-align: center;
        }
        .building-orientation-button.active {
            border-color: #4299e1;
            background-color: #bee3f8;
        }
    </style>
</head>
<body class="bg-gray-100 p-4 min-h-screen">

<canvas id="mapCanvas"></canvas>

<div class="controls-sidebar">
    <div class="controls">
        <h2 class="text-xl font-bold text-center mb-2">åœ°åœ–å·¥å…·</h2>
        <div class="flex gap-2">
            <button id="landButton" class="button land-button flex-1 mode-active">ç¹ªè£½é™¸åœ°</button>
            <button id="seaButton" class="button sea-button flex-1">ç¹ªè£½æµ·æ´‹</button>
        </div>
        <div class="flex gap-2 items-center justify-between">
            <button id="roadButton" class="button road-button flex-1">ç¹ªè£½é“è·¯</button>
            <button id="buildingButton" class="button building-button flex-1">æ”¾ç½®å»ºç¯‰</button>
        </div>
        <div class="control-group" id="brushSizeControls">
            <label for="brushSize" class="control-label">ç­†åˆ·å¤§å°: <span id="brushSizeValue"></span></label>
            <input type="range" id="brushSize" name="brushSize" min="5" max="100" value="25">
        </div>
        <div class="control-group" id="buildingSizeControls" style="display: none;">
            <label class="control-label">å»ºç¯‰ç‰©å¤§å°</label>
            <div class="building-size-group">
                <button id="building1x1" class="building-size-button active">1x1</button>
                <button id="building1x2" class="building-size-button">1x2</button>
                <button id="building2x2" class="building-size-button">2x2</button>
            </div>
        </div>
        <div class="control-group" id="buildingOrientationControls" style="display: none;">
            <label class="control-label">1x2æ–¹å‘</label>
            <div class="building-size-group">
                <button id="vertical" class="building-orientation-button active">å‚ç›´</button>
                <button id="horizontal" class="building-orientation-button">æ°´å¹³</button>
            </div>
        </div>
        <button id="clearButton" class="button clear-button">æ¸…é™¤åœ°åœ–</button>
        
        <!-- æ–°å¢çš„åŒ¯å‡º/åŒ¯å…¥æŒ‰éˆ• -->
        <div class="flex flex-col gap-2 mt-4 border-t pt-4">
            <button id="exportDataButton" class="button export-data-button">åŒ¯å‡ºåœ°åœ–è³‡æ–™</button>
            <button id="importDataButton" class="button import-data-button">åŒ¯å…¥åœ°åœ–è³‡æ–™</button>
            <button id="exportImageButton" class="button export-image-button">åŒ¯å‡ºåœ°åœ–ç•«é¢</button>
        </div>
        <input type="file" id="importFileInput" style="display: none;" accept=".mapdata">
    </div>

    <div class="info-panel">
        <p>ğŸ’¡ æç¤ºï¼šä½¿ç”¨æ»‘é¼ æ»¾è¼ªä¾†æ”¾å¤§/ç¸®å°ï¼Œ**å³éµæ‹–æ›³** æˆ– **å…©æŒ‡è§¸æ§** ä¾†ç§»å‹•åœ°åœ–ã€‚</p>
        <p>ğŸ’¡ **æ–°å¢**ï¼šå³éµé»æ“Šä¾†ç§»é™¤å»ºç¯‰ç‰©ã€‚</p>
        <p id="roadInstruction" style="display:none; color: #e53e3e; font-weight: bold;">è«‹é»æ“Šèµ·å§‹é»ä¾†ç¹ªè£½é“è·¯</p>
    </div>
</div>

<!-- è‡ªå®šç¾©ç¢ºèªå½ˆçª— -->
<div id="clearModal" class="modal">
    <div class="modal-content">
        <p class="text-lg font-bold">ç¢ºå®šè¦æ¸…é™¤åœ°åœ–å—ï¼Ÿ</p>
        <p class="mt-2 text-gray-600">æ­¤æ“ä½œå°‡ç„¡æ³•å¾©åŸã€‚</p>
        <div class="modal-buttons">
            <button id="confirmClear" class="button land-button">ç¢ºå®š</button>
            <button id="cancelClear" class="button sea-button">å–æ¶ˆ</button>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('mapCanvas');
    const ctx = canvas.getContext('2d');
    const brushSizeSlider = document.getElementById('brushSize');
    const brushSizeValueSpan = document.getElementById('brushSizeValue');
    const brushSizeControls = document.getElementById('brushSizeControls');
    const landButton = document.getElementById('landButton');
    const seaButton = document.getElementById('seaButton');
    const roadButton = document.getElementById('roadButton');
    const buildingButton = document.getElementById('buildingButton');
    const clearButton = document.getElementById('clearButton');
    const clearModal = document.getElementById('clearModal');
    const confirmClearBtn = document.getElementById('confirmClear');
    const cancelClearBtn = document.getElementById('cancelClear');
    const buildingSizeControls = document.getElementById('buildingSizeControls');
    const building1x1Btn = document.getElementById('building1x1');
    const building1x2Btn = document.getElementById('building1x2');
    const building2x2Btn = document.getElementById('building2x2');
    const buildingOrientationControls = document.getElementById('buildingOrientationControls');
    const verticalBtn = document.getElementById('vertical');
    const horizontalBtn = document.getElementById('horizontal');
    const roadInstruction = document.getElementById('roadInstruction');
    const exportDataButton = document.getElementById('exportDataButton');
    const importDataButton = document.getElementById('importDataButton');
    const exportImageButton = document.getElementById('exportImageButton');
    const importFileInput = document.getElementById('importFileInput');


    // ç•«å¸ƒå°ºå¯¸
    const setCanvasSize = () => {
        canvas.width = window.innerWidth - 300; // æ¸›å»å´é‚Šæ¬„å¯¬åº¦
        canvas.height = window.innerHeight;
    };
    setCanvasSize();

    // ç•«å¸ƒç‹€æ…‹
    let isDrawing = false;
    let isPanning = false;
    let mode = 'land'; // 'land', 'sea', 'road', 'building'
    let buildingSize = { width: 1, height: 1 };
    let buildingOrientation = 'vertical'; // 'vertical' or 'horizontal'
    let brushSize = parseInt(brushSizeSlider.value);
    let panX = 0;
    let panY = 0;
    let scale = 1;
    let lastX, lastY;

    // é“è·¯ç¹ªè£½ç‹€æ…‹
    let roadStartPoint = null;
    let tempRoadEndPoint = null;

    // åœ°åœ–è³‡æ–™ (ä½¿ç”¨ä¸€å€‹ç¨€ç– Map ä¾†å„²å­˜åƒç´ æ–¹æ ¼ç‹€æ…‹ï¼Œç¯€çœè¨˜æ†¶é«”)
    const mapData = new Map();
    // å–®ç¨å„²å­˜å»ºç¯‰ç‰©ï¼Œä»¥ä¾¿æ•´é«”ç¹ªè£½å’Œç®¡ç†
    let buildings = [];
    const cellSize = 10;

    // é¡è‰²
    const landColor = '#48bb78'; // é™¸åœ°é¡è‰²
    const seaColor = '#0077c2'; // æµ·æ´‹é¡è‰²
    const roadColor = '#64748b'; // é“è·¯é¡è‰²
    const buildingColor = '#f9a8d4'; // å»ºç¯‰ç‰©é¡è‰²
    const buildingBorderColor = '#9d2a71'; // å»ºç¯‰ç‰©é‚Šæ¡†é¡è‰²
    const buildingBorderWidth = 1;

    // æ›´æ–°ç­†åˆ·å¤§å°é¡¯ç¤º
    const updateBrushSizeDisplay = () => {
        brushSizeValueSpan.textContent = brushSizeSlider.value;
    };
    brushSizeSlider.addEventListener('input', (e) => {
        brushSize = parseInt(e.target.value);
        updateBrushSizeDisplay();
    });
    updateBrushSizeDisplay();

    // åˆ‡æ›æ¨¡å¼
    const setMode = (newMode) => {
        mode = newMode;
        document.querySelectorAll('.button').forEach(btn => btn.classList.remove('mode-active'));
        document.getElementById(`${newMode}Button`).classList.add('mode-active');
        canvas.style.cursor = 'crosshair';

        // éš±è—æ‰€æœ‰é¡å¤–çš„æ§åˆ¶é …
        brushSizeControls.style.display = 'none';
        buildingSizeControls.style.display = 'none';
        buildingOrientationControls.style.display = 'none';
        roadInstruction.style.display = 'none';
        roadStartPoint = null; // åˆ‡æ›æ¨¡å¼æ™‚æ¸…é™¤é“è·¯èµ·å§‹é»

        // é¡¯ç¤ºå°æ‡‰æ¨¡å¼çš„æ§åˆ¶é …
        if (mode === 'land' || mode === 'sea') {
            brushSizeControls.style.display = 'flex';
        } else if (mode === 'building') {
            buildingSizeControls.style.display = 'flex';
            if (buildingSize.width === 1 && buildingSize.height === 2 || buildingSize.width === 2 && buildingSize.height === 1) {
                buildingOrientationControls.style.display = 'flex';
            }
        } else if (mode === 'road') {
            roadInstruction.style.display = 'block';
        }
    };

    landButton.addEventListener('click', () => setMode('land'));
    seaButton.addEventListener('click', () => setMode('sea'));
    roadButton.addEventListener('click', () => setMode('road'));
    buildingButton.addEventListener('click', () => setMode('building'));
    
    // è¨­å®šå»ºç¯‰ç‰©å¤§å°
    const setBuildingSize = (width, height) => {
        buildingSize = { width, height };
        document.querySelectorAll('.building-size-button').forEach(btn => btn.classList.remove('active'));
        document.getElementById(`building${width}x${height}`).classList.add('active');

        // é¡¯ç¤ºæˆ–éš±è—æ–¹å‘æ§åˆ¶é …
        if (width === 1 && height === 2) {
            buildingOrientationControls.style.display = 'flex';
            buildingSize = (buildingOrientation === 'vertical') ? { width: 1, height: 2 } : { width: 2, height: 1 };
        } else {
            buildingOrientationControls.style.display = 'none';
        }
    };
    building1x1Btn.addEventListener('click', () => setBuildingSize(1, 1));
    building1x2Btn.addEventListener('click', () => setBuildingSize(1, 2));
    building2x2Btn.addEventListener('click', () => setBuildingSize(2, 2));

    // è¨­å®šå»ºç¯‰ç‰©æ–¹å‘ (åƒ…é©ç”¨æ–¼ 1x2)
    const setBuildingOrientation = (orientation) => {
        buildingOrientation = orientation;
        document.querySelectorAll('.building-orientation-button').forEach(btn => btn.classList.remove('active'));
        document.getElementById(orientation).classList.add('active');
        
        // æ ¹æ“šæ–¹å‘æ›´æ–° buildingSize
        if (orientation === 'vertical') {
            buildingSize = { width: 1, height: 2 };
        } else {
            buildingSize = { width: 2, height: 1 };
        }
    };
    verticalBtn.addEventListener('click', () => setBuildingOrientation('vertical'));
    horizontalBtn.addEventListener('click', () => setBuildingOrientation('horizontal'));

    // æ¸…é™¤åœ°åœ–å½ˆçª—
    clearButton.addEventListener('click', () => {
        clearModal.style.display = 'flex';
    });

    confirmClearBtn.addEventListener('click', () => {
        mapData.clear();
        buildings = [];
        clearModal.style.display = 'none';
        draw();
    });

    cancelClearBtn.addEventListener('click', () => {
        clearModal.style.display = 'none';
    });

    // ç¹ªè£½å¤šå€‹åƒç´ 
    const applyPixelBrush = (x, y, value) => {
        const radius = brushSize / scale;
        const cellRadius = Math.ceil(radius / cellSize);
        
        const centerX = Math.floor(x / cellSize);
        const centerY = Math.floor(y / cellSize);

        for (let i = centerX - cellRadius; i <= centerX + cellRadius; i++) {
            for (let j = centerY - cellRadius; j <= centerY + cellRadius; j++) {
                const dist = Math.sqrt(Math.pow(i * cellSize - x, 2) + Math.pow(j * cellSize - y, 2));
                if (dist <= radius) {
                    const key = `${i},${j}`;
                    if (value === 'sea') {
                        mapData.delete(key);
                    } else {
                        mapData.set(key, value);
                    }
                }
            }
        }
    };

    // ç¹ªè£½å–®å€‹åƒç´ 
    const applySinglePixel = (x, y, value) => {
        const cellX = Math.floor(x / cellSize);
        const cellY = Math.floor(y / cellSize);
        const key = `${cellX},${cellY}`;
        if (value === 'sea') {
            mapData.delete(key);
        } else {
            mapData.set(key, value);
        }
    };
    
    // ç¹ªè£½å»ºç¯‰ç‰©ï¼ˆå¤šå€‹åƒç´ ï¼‰
    const applyBuilding = (x, y) => {
        const cellX = Math.floor(x / cellSize);
        const cellY = Math.floor(y / cellSize);

        const newBuilding = {
            x: cellX,
            y: cellY,
            width: buildingSize.width,
            height: buildingSize.height,
        };

        // æª¢æŸ¥æ–°å»ºç¯‰ç‰©æ˜¯å¦èˆ‡ç¾æœ‰å»ºç¯‰ç‰©é‡ç–Š
        for (const existingBuilding of buildings) {
            if (
                cellX < existingBuilding.x + existingBuilding.width &&
                cellX + newBuilding.width > existingBuilding.x &&
                cellY < existingBuilding.y + existingBuilding.height &&
                cellY + newBuilding.height > existingBuilding.y
            ) {
                // å¦‚æœé‡ç–Šï¼Œå‰‡ä¸æ”¾ç½®æ–°å»ºç¯‰ç‰©
                return;
            }
        }
        
        // æª¢æŸ¥æ–°å»ºç¯‰ç‰©æ˜¯å¦èˆ‡é“è·¯é‡ç–Š (ç°¡å–®æª¢æŸ¥å››å€‹è§’é»)
        if (mapData.get(`${cellX},${cellY}`) === 'road' ||
            mapData.get(`${cellX + newBuilding.width - 1},${cellY}`) === 'road' ||
            mapData.get(`${cellX},${cellY + newBuilding.height - 1}`) === 'road' ||
            mapData.get(`${cellX + newBuilding.width - 1},${cellY + newBuilding.height - 1}`) === 'road') {
            return;
        }

        buildings.push(newBuilding);
    };

    // ç¹ªè£½ç›´ç·šé“è·¯
    const drawRoadLine = (startPoint, endPoint) => {
        const dx = Math.abs(endPoint.x - startPoint.x);
        const dy = Math.abs(endPoint.y - startPoint.y);
        const steps = Math.max(dx, dy);

        for (let i = 0; i <= steps; i++) {
            const x = Math.floor(startPoint.x + (endPoint.x - startPoint.x) * i / steps);
            const y = Math.floor(startPoint.y + (endPoint.y - startPoint.y) * i / steps);
            mapData.set(`${x},${y}`, 'road');
        }
    };

    // ç¹ªè£½åœ°åœ–
    const draw = () => {
        // æ¸…ç©ºç•«å¸ƒ
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // ç¹ªè£½èƒŒæ™¯ (æµ·æ´‹)
        ctx.fillStyle = seaColor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // ç¹ªè£½æ‰€æœ‰åœ°åœ–å…ƒç´  (é™¸åœ°å’Œé“è·¯)
        mapData.forEach((value, key) => {
            const [cellX, cellY] = key.split(',').map(Number);
            const x = cellX * cellSize * scale + panX;
            const y = cellY * cellSize * scale + panY;
            const size = cellSize * scale;
            
            // åªç¹ªè£½åœ¨è¦–çª—å…§çš„å¯è¦‹éƒ¨åˆ†ï¼Œæå‡æ•ˆèƒ½
            if (x + size > 0 && y + size > 0 && x < canvas.width && y < canvas.height) {
                switch (value) {
                    case 'land':
                        ctx.fillStyle = landColor;
                        ctx.fillRect(x, y, size, size);
                        break;
                    case 'road':
                        ctx.fillStyle = roadColor;
                        ctx.fillRect(x, y, size, size);
                        break;
                }
            }
        });

        // ç¨ç«‹ç¹ªè£½æ‰€æœ‰å»ºç¯‰ç‰©
        buildings.forEach(building => {
            const x = building.x * cellSize * scale + panX;
            const y = building.y * cellSize * scale + panY;
            const width = building.width * cellSize * scale;
            const height = building.height * cellSize * scale;

            // åªç¹ªè£½åœ¨è¦–çª—å…§çš„å¯è¦‹éƒ¨åˆ†
            if (x + width > 0 && y + height > 0 && x < canvas.width && y < canvas.height) {
                // ç¹ªè£½å…§éƒ¨
                ctx.fillStyle = buildingColor;
                ctx.fillRect(x, y, width, height);

                // ç¹ªè£½å¤–éƒ¨é‚Šæ¡†
                ctx.fillStyle = buildingBorderColor;
                // top
                ctx.fillRect(x, y, width, buildingBorderWidth * scale);
                // bottom
                ctx.fillRect(x, y + height - buildingBorderWidth * scale, width, buildingBorderWidth * scale);
                // left
                ctx.fillRect(x, y, buildingBorderWidth * scale, height);
                // right
                ctx.fillRect(x + width - buildingBorderWidth * scale, y, buildingBorderWidth * scale, height);
            }
        });

        // ç¹ªè£½é“è·¯é è¦½ç·š
        if (mode === 'road' && roadStartPoint) {
            ctx.beginPath();
            ctx.strokeStyle = '#f0a300';
            ctx.lineWidth = cellSize * scale * 0.5;
            ctx.lineCap = 'round';
            ctx.moveTo(roadStartPoint.x * cellSize * scale + panX, roadStartPoint.y * cellSize * scale + panY);
            if (tempRoadEndPoint) {
                ctx.lineTo(tempRoadEndPoint.x * cellSize * scale + panX, tempRoadEndPoint.y * cellSize * scale + panY);
            }
            ctx.stroke();
        }
    };
    
    // æ¸²æŸ“è¿´åœˆï¼Œå„ªåŒ–ç¹ªåœ–é »ç‡
    const gameLoop = () => {
        draw();
        requestAnimationFrame(gameLoop);
    };
    gameLoop();

    // ç§»é™¤å»ºç¯‰ç‰©
    const removeBuilding = (mapX, mapY) => {
        const cellX = Math.floor(mapX / cellSize);
        const cellY = Math.floor(mapY / cellSize);
        
        // æ‰¾åˆ°é»æ“Šçš„å»ºç¯‰ç‰©
        const indexToRemove = buildings.findIndex(building => {
            return cellX >= building.x && cellX < building.x + building.width &&
                   cellY >= building.y && cellY < building.y + building.height;
        });

        if (indexToRemove !== -1) {
            buildings.splice(indexToRemove, 1);
        }
    };

    // åŒ¯å‡ºåœ°åœ–è³‡æ–™
    const exportMapData = () => {
        const data = {
            mapData: Array.from(mapData.entries()),
            buildings: buildings,
        };
        const jsonString = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonString], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'map.mapdata';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    };

    // åŒ¯å…¥åœ°åœ–è³‡æ–™
    const importMapData = (file) => {
        if (!file) {
            console.error("æ²’æœ‰é¸æ“‡æª”æ¡ˆã€‚");
            return;
        }

        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const data = JSON.parse(event.target.result);

                // æ¸…ç©ºç•¶å‰åœ°åœ–
                mapData.clear();
                buildings = [];

                // è¼‰å…¥æ–°çš„åœ°åœ–è³‡æ–™
                if (data.mapData) {
                    data.mapData.forEach(item => {
                        mapData.set(item[0], item[1]);
                    });
                }
                if (data.buildings) {
                    buildings = data.buildings;
                }

                draw(); // é‡æ–°ç¹ªè£½åœ°åœ–
            } catch (error) {
                console.error("è®€å–æª”æ¡ˆå¤±æ•—ï¼š", error);
            }
        };
        reader.readAsText(file);
    };

    // åŒ¯å‡ºåœ°åœ–ç•«é¢
    const exportMapImage = () => {
        const dataURL = canvas.toDataURL('image/png');
        const a = document.createElement('a');
        a.href = dataURL;
        a.download = 'map.png';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    };


    // æ»‘é¼ äº‹ä»¶ç›£è½å™¨
    canvas.addEventListener('mousedown', (e) => {
        // é˜»æ­¢å³éµèœå–®
        if (e.button === 2) e.preventDefault();

        const rect = canvas.getBoundingClientRect();
        const mapX = (e.clientX - rect.left - panX) / scale;
        const mapY = (e.clientY - rect.top - panY) / scale;
        const cellX = Math.floor(mapX / cellSize);
        const cellY = Math.floor(mapY / cellSize);

        // å·¦éµç¹ªè£½/æ”¾ç½®
        if (e.button === 0) {
            isDrawing = true;
            
            if (mode === 'land' || mode === 'sea') {
                applyPixelBrush(mapX, mapY, mode);
            } else if (mode === 'building') {
                applyBuilding(mapX, mapY);
            } else if (mode === 'road') {
                if (!roadStartPoint) {
                    roadStartPoint = { x: cellX, y: cellY };
                    roadInstruction.textContent = 'è«‹é»æ“ŠçµæŸé»ä¾†å®Œæˆé“è·¯';
                } else {
                    drawRoadLine(roadStartPoint, { x: cellX, y: cellY });
                    roadStartPoint = null;
                    tempRoadEndPoint = null;
                    roadInstruction.textContent = 'é“è·¯å·²ç¹ªè£½ã€‚å†æ¬¡é»æ“Šä»¥é–‹å§‹æ–°é“è·¯ã€‚';
                }
            }
        } 
        // å³éµå¹³ç§»æˆ–ç§»é™¤å»ºç¯‰ç‰©
        else if (e.button === 2) {
            if (mode === 'building') {
                removeBuilding(mapX, mapY);
            } else {
                isPanning = true;
                lastX = e.clientX;
                lastY = e.clientY;
                canvas.style.cursor = 'grab';
            }
        }
    });

    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        const mapX = (e.clientX - rect.left - panX) / scale;
        const mapY = (e.clientY - rect.top - panY) / scale;
        
        // å¹³ç§»æ¨¡å¼
        if (isPanning) {
            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;
            panX += dx;
            panY += dy;
            lastX = e.clientX;
            lastY = e.clientY;
        } 
        // ç¹ªè£½æ¨¡å¼
        else if (isDrawing) {
            if (mode === 'land' || mode === 'sea') {
                applyPixelBrush(mapX, mapY, mode);
            }
        } else if (mode === 'road' && roadStartPoint) {
            const cellX = Math.floor(mapX / cellSize);
            const cellY = Math.floor(mapY / cellSize);
            tempRoadEndPoint = { x: cellX, y: cellY };
        }
    });

    canvas.addEventListener('mouseup', () => {
        isDrawing = false;
        isPanning = false;
        canvas.style.cursor = 'crosshair';
    });

    canvas.addEventListener('mouseleave', () => {
        isDrawing = false;
        isPanning = false;
        canvas.style.cursor = 'crosshair';
    });

    // ç¦æ­¢å³éµèœå–®
    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    // è§¸æ§äº‹ä»¶ç›£è½å™¨
    let touchPoints = [];
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        touchPoints = Array.from(e.touches);
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        const mapX = (touch.clientX - rect.left - panX) / scale;
        const mapY = (touch.clientY - rect.top - panY) / scale;
        const cellX = Math.floor(mapX / cellSize);
        const cellY = Math.floor(mapY / cellSize);


        if (e.touches.length === 1) {
            isDrawing = true;
            
            if (mode === 'land' || mode === 'sea') {
                applyPixelBrush(mapX, mapY, mode);
            } else if (mode === 'building') {
                applyBuilding(mapX, mapY);
            } else if (mode === 'road') {
                if (!roadStartPoint) {
                    roadStartPoint = { x: cellX, y: cellY };
                    roadInstruction.textContent = 'è«‹é»æ“ŠçµæŸé»ä¾†å®Œæˆé“è·¯';
                } else {
                    drawRoadLine(roadStartPoint, { x: cellX, y: cellY });
                    roadStartPoint = null;
                    tempRoadEndPoint = null;
                    roadInstruction.textContent = 'é“è·¯å·²ç¹ªè£½ã€‚å†æ¬¡é»æ“Šä»¥é–‹å§‹æ–°é“è·¯ã€‚';
                }
            }
        } else if (e.touches.length === 2) {
            isPanning = true;
        }
    });

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const currentTouchPoints = Array.from(e.touches);
        const rect = canvas.getBoundingClientRect();
        
        if (touchPoints.length === 2 && currentTouchPoints.length === 2) {
            // é›™æŒ‡å¹³ç§»èˆ‡ç¸®æ”¾
            const touch1 = currentTouchPoints[0];
            const touch2 = currentTouchPoints[1];
            const prevTouch1 = touchPoints[0];
            const prevTouch2 = touchPoints[1];

            // ç¸®æ”¾
            const dist = Math.sqrt(Math.pow(touch2.clientX - touch1.clientX, 2) + Math.pow(touch2.clientY - touch1.clientY, 2));
            const prevDist = Math.sqrt(Math.pow(prevTouch2.clientX - prevTouch1.clientX, 2) + Math.pow(prevTouch2.clientY - prevTouch1.clientY, 2));
            if (prevDist > 0) {
                const scaleFactor = dist / prevDist;
                scale *= scaleFactor;
            }

            // å¹³ç§»
            const midX = (touch1.clientX + touch2.clientX) / 2;
            const midY = (touch1.clientY + touch2.clientY) / 2;
            const prevMidX = (prevTouch1.clientX + prevTouch2.clientX) / 2;
            const prevMidY = (prevTouch1.clientY + prevTouch2.clientY) / 2;
            panX += midX - prevMidX;
            panY += midY - prevMidY;

        } else if (isDrawing && currentTouchPoints.length === 1) {
            // å–®æŒ‡ç¹ªè£½
            const mapX = (e.touches[0].clientX - rect.left - panX) / scale;
            const mapY = (e.touches[0].clientY - rect.top - panY) / scale;

            if (mode === 'land' || mode === 'sea') {
                applyPixelBrush(mapX, mapY, mode);
            }
        }
        touchPoints = currentTouchPoints;
    });

    canvas.addEventListener('touchend', () => {
        isDrawing = false;
        isPanning = false;
        touchPoints = [];
    });

    // æ»¾è¼ªç¸®æ”¾
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const scaleFactor = 1.1;
        const oldScale = scale;

        if (e.deltaY < 0) { // æ”¾å¤§
            scale *= scaleFactor;
        } else { // ç¸®å°
            scale /= scaleFactor;
        }

        // ä¿æŒç¸®æ”¾ä¸­å¿ƒ
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        const dx = mouseX - panX;
        const dy = mouseY - panY;

        panX = mouseX - dx * (scale / oldScale);
        panY = mouseY - dy * (scale / oldScale);
    });

    // è¦–çª—å¤§å°æ”¹è®Šæ™‚èª¿æ•´ç•«å¸ƒå¤§å°
    window.addEventListener('resize', () => {
        setCanvasSize();
    });
    
    // åŒ¯å‡ºæŒ‰éˆ•äº‹ä»¶ç›£è½å™¨
    exportDataButton.addEventListener('click', exportMapData);
    exportImageButton.addEventListener('click', exportMapImage);

    // åŒ¯å…¥æŒ‰éˆ•äº‹ä»¶ç›£è½å™¨
    importDataButton.addEventListener('click', () => {
        importFileInput.click();
    });

    importFileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
            importMapData(file);
        }
    });

    // åˆå§‹è¨­å®š
    setMode('land');
    setBuildingSize(1, 1);
</script>
</body>
</html>
