<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>吃太多不各了!</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            width: 100vw;
            /* --- 顏色調整 --- */
            background-color: #e0e0e0; /* 更淺的灰色背景 */
            /* --- 變更結束 --- */
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            perspective: 1000px;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            border: 2px solid #333;
            /* --- 顏色調整 --- */
            background-color: #f5f5f5; /* 淺灰色遊戲區域 */
            /* --- 變更結束 --- */
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.5s ease-in-out;
            box-sizing: border-box;
        }

        /* --- 迷幻效果 CSS 類別 (保持晃動效果) --- */
        .psychedelic-effect {
            animation: subtleShake 0.5s infinite alternate;
        }

        @keyframes subtleShake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            25% { transform: translate(-1px, -2px) rotate(-1deg); }
            50% { transform: translate(-3px, 0px) rotate(1deg); }
            75% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -1px) rotate(-1deg); }
        }
        /* --- 迷幻效果 CSS 類別結束 --- */

        /* --- 飛出幾何圖形的 CSS --- */
        .flying-shape {
            position: absolute;
            /* --- 顏色調整 --- */
            background-color: rgba(100, 100, 100, 0.5); /* 預設深灰色半透明 */
            /* --- 變更結束 --- */
            border-radius: 0;
            pointer-events: none;
            z-index: 5;
            animation: shapeShake 0.2s infinite alternate;
        }

        @keyframes shapeShake {
            0% { transform: translate(0, 0); }
            50% { transform: translate(1px, 1px); }
            100% { transform: translate(-1px, -1px); }
        }
        /* --- 飛出幾何圖形的 CSS 結束 --- */

        /* --- 迷幻效果控制面板 CSS --- */
        #effect-controls {
            position: absolute;
            top: 10px;
            left: 10px;
            /* --- 顏色調整 --- */
            background-color: rgba(50, 50, 50, 0.7); /* 更深的灰色半透明 */
            /* --- 變更結束 --- */
            padding: 15px;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            z-index: 200;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 250px;
        }

        #effect-controls label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        #effect-controls input[type="range"] {
            width: 150px;
            margin-left: 10px;
        }
        /* --- 迷幻效果控制面板 CSS 結束 --- */

        #ground {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 30px;
            /* --- 顏色調整 --- */
            background-color: #666; /* 地面深灰色 */
            /* --- 變更結束 --- */
            z-index: 10;
        }

        #dino {
            width: 40px;
            height: 60px;
            /* --- 顏色調整 --- */
            background-color: #888; /* 恐龍中灰色 */
            /* --- 變更結束 --- */
            position: absolute;
            bottom: 30px;
            left: 50px;
            border-radius: 5px;
            transition: bottom 0.1s ease-out;
            z-index: 20;
        }

        .obstacle {
            width: 20px;
            height: 40px;
            /* --- 顏色調整 --- */
            background-color: #444; /* 障礙物深灰色 */
            /* --- 變更結束 --- */
            position: absolute;
            bottom: 30px;
            right: 0;
            border-radius: 3px;
            z-index: 15;
            transition: transform 0.1s linear;
        }

        .chaos-item {
            width: 25px;
            height: 25px;
            /* --- 顏色調整 --- */
            background-color: #777; /* 道具中灰色 */
            /* --- 變更結束 --- */
            position: absolute;
            bottom: 60px;
            right: 0;
            border-radius: 50%;
            z-index: 18;
        }

        .psychedelic-item {
            width: 30px;
            height: 30px;
            /* --- 顏色調整 --- */
            background-color: #aaaa00; /* 迷幻道具可以保留一點點顏色，或是使用亮灰色 */
            /* 這裡我選擇稍微帶點黃色的灰色，增加一點點點綴 */
            /* 如果要純灰色，可以改為 #ccc */
            /* --- 變更結束 --- */
            position: absolute;
            bottom: 90px;
            right: 0;
            border-radius: 50%;
            z-index: 19;
            /* --- 顏色調整 --- */
            box-shadow: 0 0 10px #aaaa00, 0 0 20px #aaaa00; /* 配合道具顏色 */
            /* 如果要純灰色，可以改為 box-shadow: 0 0 10px #ccc, 0 0 20px #ccc; */
            /* --- 變更結束 --- */
        }

        #score {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 20px;
            /* --- 顏色調整 --- */
            color: #333; /* 分數顏色深灰色 */
            /* --- 變更結束 --- */
            z-index: 100;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            /* --- 顏色調整 --- */
            color: #a00000; /* 遊戲結束可以保留一點警示紅，或者改為深灰色 #555 */
            /* --- 變更結束 --- */
            text-align: center;
            display: none;
            z-index: 101;
        }

        #start-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 30px;
            font-size: 24px;
            /* --- 顏色調整 --- */
            background-color: #555; /* 按鈕背景灰色 */
            color: white; /* 按鈕文字白色 */
            /* --- 變更結束 --- */
            border: none;
            border-radius: 8px;
            cursor: pointer;
            z-index: 102;
        }
    </style>
</head>
<body>
    <svg width="0" height="0" style="position: absolute;">
        <filter id="fisheyeDistort">
            <feTurbulence id="feTurbulence" type="fractalNoise" baseFrequency="0.05" numOctaves="3" result="noise" />
            <feDisplacementMap id="feDisplacementMap" in="SourceGraphic" in2="noise" scale="10" xChannelSelector="R" yChannelSelector="G" />
        </filter>
    </svg>

    <div id="game-container">
        <div id="ground"></div>
        <div id="dino"></div>
        <div id="score">分數: 0</div>
        <div id="game-over">遊戲結束！<br>點擊重新開始</div>
        <button id="start-button">開始遊戲</button>
    </div>

    <div id="effect-controls">
        <h3>迷幻效果設定</h3>
        <label>
            模糊 (px):
            <input type="range" id="blur-slider" min="0.5" max="10" step="0.1" value="5">
            <span id="blur-value">5.0</span>
        </label>
        <label>
            色相旋轉 (deg):
            <input type="range" id="hue-rotate-slider" min="10" max="360" step="1" value="360">
            <span id="hue-rotate-value">360</span>
        </label>
        <label>
            對比度 (%):
            <input type="range" id="contrast-slider" min="60" max="200" step="1" value="150">
            <span id="contrast-value">150</span>
        </label>
        <label>
            扭曲頻率:
            <input type="range" id="base-frequency-slider" min="0.01" max="0.2" step="0.01" value="0.1">
            <span id="base-frequency-value">0.10</span>
        </label>
        <label>
            扭曲強度:
            <input type="range" id="scale-slider" min="5" max="50" step="1" value="30">
            <span id="scale-value">30</span>
        </label>
    </div>

    <script>
        const gameContainer = document.getElementById('game-container');
        const dino = document.getElementById('dino');
        const scoreDisplay = document.getElementById('score');
        const gameOverDisplay = document.getElementById('game-over');
        const startButton = document.getElementById('start-button');

        const feTurbulence = document.getElementById('feTurbulence');
        const feDisplacementMap = document.getElementById('feDisplacementMap');

        const blurSlider = document.getElementById('blur-slider');
        const blurValueSpan = document.getElementById('blur-value');
        const hueRotateSlider = document.getElementById('hue-rotate-slider');
        const hueRotateValueSpan = document.getElementById('hue-rotate-value');
        const contrastSlider = document.getElementById('contrast-slider');
        const contrastValueSpan = document.getElementById('contrast-value');
        const baseFrequencySlider = document.getElementById('base-frequency-slider');
        const baseFrequencyValueSpan = document.getElementById('base-frequency-value');
        const scaleSlider = document.getElementById('scale-slider');
        const scaleValueSpan = document.getElementById('scale-value');

        let isGameOver = true;
        let score = 0;
        let dinoBottom = 30;
        let gravity = 0.9;
        let isJumping = false;
        let obstacles = [];
        let chaosItems = [];
        let psychedelicItems = [];
        let flyingShapes = [];
        let gameSpeed = 5;
        let obstacleGenerationInterval;
        let chaosItemGenerationInterval;
        let psychedelicItemGenerationInterval;
        let gameLoopInterval;
        let rotationState = 0;

        let psychedelicEffectInterval;
        let flyingShapeGenerationInterval;

        function initGame() {
            isGameOver = false;
            score = 0;
            scoreDisplay.textContent = '分數: 0';
            gameOverDisplay.style.display = 'none';
            startButton.style.display = 'none';

            obstacles.forEach(obstacle => obstacle.element.remove());
            obstacles = [];
            chaosItems.forEach(item => item.element.remove());
            chaosItems = [];
            psychedelicItems.forEach(item => item.element.remove());
            psychedelicItems = [];
            flyingShapes.forEach(shape => shape.element.remove());
            flyingShapes = [];

            dinoBottom = 30;
            dino.style.bottom = `${dinoBottom}px`;
            gameSpeed = 5;
            rotationState = 0;
            gameContainer.style.transform = 'none';

            enablePsychedelicEffect();
            startPsychedelicEffectRandomizer();
            startFlyingShapeGeneration();

            startGameLoop();
            startObstacleGeneration();
            startChaosItemGeneration();
            startPsychedelicItemGeneration();
        }

        function startGameLoop() {
            gameLoopInterval = setInterval(() => {
                if (isGameOver) {
                    clearInterval(gameLoopInterval);
                    return;
                }

                updateDino();
                updateObstacles();
                updateChaosItems();
                updatePsychedelicItems();
                updateFlyingShapes();
                checkCollisions();

                score++;
                scoreDisplay.textContent = `分數: ${score}`;

                if (score % 200 === 0) {
                    gameSpeed += 0.5;
                }
            }, 20);
        }

        function jump() {
            if (!isJumping && !isGameOver) {
                isJumping = true;
                let jumpHeight = 150;
                let jumpVelocity = 15;

                const upInterval = setInterval(() => {
                    if (dinoBottom < jumpHeight && jumpVelocity > 0) {
                        dinoBottom += jumpVelocity;
                        dino.style.bottom = `${dinoBottom}px`;
                        jumpVelocity -= gravity;
                    } else {
                        clearInterval(upInterval);
                        const downInterval = setInterval(() => {
                            if (dinoBottom > 30) {
                                dinoBottom -= jumpVelocity;
                                if (dinoBottom < 30) dinoBottom = 30;
                                dino.style.bottom = `${dinoBottom}px`;
                                jumpVelocity += gravity;
                            } else {
                                clearInterval(downInterval);
                                isJumping = false;
                            }
                        }, 20);
                    }
                }, 20);
            }
        }

        function updateDino() {
            // 恐龍不受重力影響，只在跳躍時移動
        }

        function createObstacle() {
            if (isGameOver) return;

            const obstacle = document.createElement('div');
            obstacle.classList.add('obstacle');
            gameContainer.appendChild(obstacle);

            let obstacleLeft = gameContainer.offsetWidth;
            let obstacleSpeed = gameSpeed + Math.random() * 3;
            let willJump = Math.random() < 0.3;

            obstacle.style.left = `${obstacleLeft}px`;
            obstacle.style.height = `${40 + Math.random() * 30}px`;

            obstacles.push({ element: obstacle, left: obstacleLeft, speed: obstacleSpeed, willJump: willJump, isJumping: false, jumpVelocity: 0, initialBottom: 30 });
        }

        function startObstacleGeneration() {
            obstacleGenerationInterval = setInterval(createObstacle, Math.random() * 1000 + 1000);
        }

        function updateObstacles() {
            obstacles.forEach((obs, index) => {
                if (obs.willJump && !obs.isJumping && obs.left < (gameContainer.offsetWidth * 0.75) && Math.random() < 0.005) {
                    obs.isJumping = true;
                    obs.jumpVelocity = 10 + Math.random() * 5;
                    obs.initialBottom = parseInt(obs.element.style.bottom) || 30;
                }

                if (obs.isJumping) {
                    obs.initialBottom += obs.jumpVelocity;
                    obs.jumpVelocity -= gravity * 1.5;
                    obs.element.style.bottom = `${obs.initialBottom}px`;
                    if (obs.initialBottom <= 30 && obs.jumpVelocity < 0) {
                        obs.initialBottom = 30;
                        obs.element.style.bottom = '30px';
                        obs.isJumping = false;
                        obs.jumpVelocity = 0;
                    }
                }

                obs.left -= obs.speed;
                obs.element.style.left = `${obs.left}px`;

                if (obs.left < -obs.element.offsetWidth) {
                    obs.element.remove();
                    obstacles.splice(index, 1);
                }
            });
        }

        function createChaosItem() {
            if (isGameOver) return;

            const item = document.createElement('div');
            item.classList.add('chaos-item');
            gameContainer.appendChild(item);

            let itemLeft = gameContainer.offsetWidth;
            item.style.left = `${itemLeft}px`;
            item.style.bottom = `${60 + Math.random() * 80}px`;

            chaosItems.push({ element: item, left: itemLeft, speed: gameSpeed * 0.8 });
        }

        function startChaosItemGeneration() {
            chaosItemGenerationInterval = setInterval(createChaosItem, Math.random() * 5000 + 5000);
        }

        function updateChaosItems() {
            chaosItems.forEach((item, index) => {
                item.left -= item.speed;
                item.element.style.left = `${item.left}px`;

                if (item.left < -item.element.offsetWidth) {
                    item.element.remove();
                    chaosItems.splice(index, 1);
                }
            });
        }

        function applyChaosEffect() {
            rotationState = (rotationState + 1) % 3;

            if (rotationState === 1) {
                gameContainer.style.transform = 'scaleX(-1)';
            } else if (rotationState === 2) {
                gameContainer.style.transform = 'scaleY(-1)';
            } else {
                gameContainer.style.transform = 'none';
            }
        }

        function createPsychedelicItem() {
            if (isGameOver) return;

            const item = document.createElement('div');
            item.classList.add('psychedelic-item');
            gameContainer.appendChild(item);

            let itemLeft = gameContainer.offsetWidth;
            item.style.left = `${itemLeft}px`;
            item.style.bottom = `${90 + Math.random() * 50}px`;

            psychedelicItems.push({ element: item, left: itemLeft, speed: gameSpeed * 0.7 });
        }

        function startPsychedelicItemGeneration() {
            psychedelicItemGenerationInterval = setInterval(createPsychedelicItem, Math.random() * 8000 + 8000);
        }

        function updatePsychedelicItems() {
            psychedelicItems.forEach((item, index) => {
                item.left -= item.speed;
                item.element.style.left = `${item.left}px`;

                if (item.left < -item.element.offsetWidth) {
                    item.element.remove();
                    psychedelicItems.splice(index, 1);
                }
            });
        }

        function enablePsychedelicEffect() {
            gameContainer.classList.add('psychedelic-effect');
            updatePsychedelicFilters();
        }

        function disablePsychedelicEffect() {
            gameContainer.classList.remove('psychedelic-effect');
            gameContainer.style.filter = `none`;
            clearInterval(psychedelicEffectInterval);
        }

        function updatePsychedelicFilters() {
            const maxBlur = parseFloat(blurSlider.value);
            const maxHueRotate = parseFloat(hueRotateSlider.value);
            const maxContrast = parseFloat(contrastSlider.value);
            const maxBaseFrequency = parseFloat(baseFrequencySlider.value);
            const maxScale = parseFloat(scaleSlider.value);

            const minBlur = 0.5;
            const minHueRotate = 10;
            const minContrast = 60;
            const minBaseFrequency = 0.01;
            const minScale = 5;

            const blurAmount = (minBlur + Math.random() * (maxBlur - minBlur)).toFixed(1);
            const hueRotateAmount = (minHueRotate + Math.random() * (maxHueRotate - minHueRotate)).toFixed(0);
            const contrastAmount = (minContrast + Math.random() * (maxContrast - minContrast)).toFixed(0);

            const newBaseFrequency = (minBaseFrequency + Math.random() * (maxBaseFrequency - minBaseFrequency)).toFixed(2);
            const newScale = (minScale + Math.random() * (maxScale - minScale)).toFixed(0);

            feTurbulence.setAttribute('baseFrequency', newBaseFrequency);
            feDisplacementMap.setAttribute('scale', newScale);

            gameContainer.style.filter = `blur(${blurAmount}px) hue-rotate(${hueRotateAmount}deg) contrast(${contrastAmount}%) url(#fisheyeDistort)`;

            blurValueSpan.textContent = blurAmount;
            hueRotateValueSpan.textContent = hueRotateAmount;
            contrastValueSpan.textContent = contrastAmount;
            baseFrequencyValueSpan.textContent = newBaseFrequency;
            scaleValueSpan.textContent = newScale;
        }

        function startPsychedelicEffectRandomizer() {
            psychedelicEffectInterval = setInterval(updatePsychedelicFilters, Math.random() * 2000 + 1000);
        }

        function createFlyingShape() {
            if (isGameOver) return;

            const shape = document.createElement('div');
            shape.classList.add('flying-shape');
            document.body.appendChild(shape);

            const size = 30 + Math.random() * 70;
            shape.style.width = `${size}px`;
            shape.style.height = `${size}px`;

            if (Math.random() < 0.5) {
                shape.style.borderRadius = '50%';
            } else {
                shape.style.borderRadius = '0';
            }

            // --- 顏色調整：生成隨機灰色系的顏色 ---
            const grayValue = Math.floor(Math.random() * 150) + 50; // 50-200 的灰度值
            const a = (0.3 + Math.random() * 0.4).toFixed(1);
            shape.style.backgroundColor = `rgba(${grayValue}, ${grayValue}, ${grayValue}, ${a})`;
            // --- 變更結束 ---

            const startLeft = Math.random() * (window.innerWidth - size);
            shape.style.left = `${startLeft}px`;
            shape.style.top = `-${size}px`;

            const initialRotate = Math.random() * 360;
            const skewX = (Math.random() * 40) - 20;
            const skewY = (Math.random() * 40) - 20;
            const scaleTransform = 0.8 + Math.random() * 0.4;
            shape.style.transform = `rotate(${initialRotate}deg) skewX(${skewX}deg) skewY(${skewY}deg) scale(${scaleTransform})`;

            const maxBlur = parseFloat(blurSlider.value);
            const maxHueRotate = parseFloat(hueRotateSlider.value);
            const maxContrast = parseFloat(contrastSlider.value);

            const minBlur = 0.5;
            const minHueRotate = 10;
            const minContrast = 60;

            const shapeBlur = (minBlur + Math.random() * (maxBlur - minBlur)).toFixed(1);
            // --- 顏色調整：下落圖形在灰色系主題下，hue-rotate 可能會讓它「突然有顏色」
            // 如果你希望它保持灰色調，可以將 hue-rotate 設為 0 或較小的固定值。
            // 這裡我讓它仍然隨機，但如果你覺得太突兀，可以考慮固定它。
            const shapeHueRotate = (minHueRotate + Math.random() * (maxHueRotate - minHueRotate)).toFixed(0);
            // --- 變更結束 ---
            const shapeContrast = (minContrast + Math.random() * (maxContrast - minContrast)).toFixed(0);

            shape.style.filter = `blur(${shapeBlur}px) hue-rotate(${shapeHueRotate}deg) contrast(${shapeContrast}%)`;

            const speed = 1 + Math.random() * 3;

            flyingShapes.push({ element: shape, top: -size, speed: speed });
        }

        function startFlyingShapeGeneration() {
            flyingShapeGenerationInterval = setInterval(createFlyingShape, Math.random() * 400 + 100);
        }

        function updateFlyingShapes() {
            const windowHeight = window.innerHeight;

            flyingShapes.forEach((shape, index) => {
                shape.top += shape.speed;
                shape.element.style.top = `${shape.top}px`;

                if (shape.top > windowHeight) {
                    shape.element.remove();
                    flyingShapes.splice(index, 1);
                }
            });
        }

        function checkCollisions() {
            const dinoRect = dino.getBoundingClientRect();

            obstacles.forEach(obs => {
                const obsRect = obs.element.getBoundingClientRect();

                if (dinoRect.left < obsRect.right &&
                    dinoRect.right > obsRect.left &&
                    dinoRect.top < obsRect.bottom &&
                    dinoRect.bottom > obsRect.top) {
                    gameOver();
                }
            });

            chaosItems.forEach((item, index) => {
                const itemRect = item.element.getBoundingClientRect();

                if (dinoRect.left < itemRect.right &&
                    dinoRect.right > itemRect.left &&
                    dinoRect.top < itemRect.bottom &&
                    dinoRect.bottom > itemRect.top) {
                    applyChaosEffect();
                    item.element.remove();
                    chaosItems.splice(index, 1);
                }
            });

            psychedelicItems.forEach((item, index) => {
                const itemRect = item.element.getBoundingClientRect();

                if (dinoRect.left < itemRect.right &&
                    dinoRect.right > itemRect.left &&
                    dinoRect.top < itemRect.bottom &&
                    dinoRect.bottom > itemRect.top) {
                    item.element.remove();
                    psychedelicItems.splice(index, 1);
                }
            });
        }

        function gameOver() {
            isGameOver = true;
            clearInterval(gameLoopInterval);
            clearInterval(obstacleGenerationInterval);
            clearInterval(chaosItemGenerationInterval);
            clearInterval(psychedelicItemGenerationInterval);
            clearInterval(psychedelicEffectInterval);
            clearInterval(flyingShapeGenerationInterval);
            gameOverDisplay.style.display = 'block';
            startButton.style.display = 'block';
            startButton.textContent = '重新開始';
            gameContainer.style.transform = 'none';
            rotationState = 0;
            disablePsychedelicEffect();
        }

        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space' && !isGameOver) {
                jump();
            }
        });

        window.addEventListener('load', () => {
            enablePsychedelicEffect();
            startPsychedelicEffectRandomizer();
            startButton.style.display = 'block';
            startFlyingShapeGeneration();
        });

        startButton.addEventListener('click', () => {
            initGame();
        });

        blurSlider.addEventListener('input', updatePsychedelicFilters);
        hueRotateSlider.addEventListener('input', updatePsychedelicFilters);
        contrastSlider.addEventListener('input', updatePsychedelicFilters);
        baseFrequencySlider.addEventListener('input', updatePsychedelicFilters);
        scaleSlider.addEventListener('input', updatePsychedelicFilters);
    </script>
</body>
</html>