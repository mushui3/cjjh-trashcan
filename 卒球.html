<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ­»äº¡è¶³çƒï¼šæ‹–æ›³ç™¼å°„èˆ‡æ’æ“Šæ·˜æ±° (10 vs 10)</title>
    <style>
        /* CSS æ¨£å¼ */
        body {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            margin: 0;
            padding-top: 20px;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
            gap: 20px;
        }
        #gameArea {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #gameCanvas {
            border: 5px solid #333;
            background-color: #008000; /* è‰åœ°é¡è‰² */
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            cursor: pointer;
        }
        #scoreBoard {
            margin-bottom: 10px;
            font-size: 28px;
            font-weight: bold;
            color: #333;
        }
        #message {
            margin-top: 10px;
            font-size: 20px;
            color: #333;
            height: 30px;
        }
        .player-info {
            font-size: 16px;
            margin-top: 5px;
        }
        .blue-text { color: blue; }
        .red-text { color: red; }

        /* éŠæˆ²æ­·ç¨‹è¦–çª—æ¨£å¼ */
        #gameLogContainer {
            width: 300px;
            height: 600px; 
            background-color: #fff;
            border: 2px solid #555;
            box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
        }
        #logTitle {
            padding: 10px;
            font-size: 18px;
            font-weight: bold;
            background-color: #333;
            color: white;
            text-align: center;
        }
        #gameLog {
            flex-grow: 1;
            overflow-y: auto; 
            padding: 10px;
            font-size: 14px;
            line-height: 1.4;
            display: flex;
            flex-direction: column-reverse; /* æ–°è¨Šæ¯åœ¨åº•éƒ¨ */
        }
        .log-entry {
            padding: 3px 0;
            border-bottom: 1px dotted #eee;
        }
        .log-goal { color: darkgreen; font-weight: bold; }
        .log-kill { color: darkred; font-weight: bold; }
        .log-info { color: gray; }
    </style>
</head>
<body>

    <div id="gameArea">
        <div id="scoreBoard">âš½ è—éšŠ: 0 - ç´…éšŠ: 0 âš½</div>
        <canvas id="gameCanvas" width="800" height="500"></canvas>
        <div id="message">éŠæˆ²è¼‰å…¥ä¸­...</div>
        <div class="player-info">
            <span class="blue-text">è—éšŠ</span> (å·¦åŠå ´, ç©å®¶æ“ä½œ) | 
            <span class="red-text">ç´…éšŠ</span> (å³åŠå ´, AIè‡ªå‹•ç™¼å°„)
        </div>
        <div class="player-info">
            ğŸš¨ **æ’æ“Šæ·˜æ±°è¦å‰‡**ï¼šçƒå“¡é«˜é€Ÿå°æ’æ™‚ï¼Œé€Ÿåº¦è¼ƒæ…¢çš„ä¸€æ–¹æœ‰<span style="font-weight: bold; color: darkred;">æ©Ÿç‡</span>è¢«æ’å‡ºå±€ï¼<span style="color: blue;">(åŒéšŠæ’æ“Šå®‰å…¨ï¼Œæ©Ÿç‡éš¨äººæ•¸æ¸›å°‘è€Œé™ä½)</span>
        </div>
    </div>

    <div id="gameLogContainer">
        <div id="logTitle">ğŸ“ éŠæˆ²æ­·ç¨‹</div>
        <div id="gameLog">
            </div>
    </div>

    <script>
        // JavaScript éŠæˆ²é‚è¼¯
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreBoard = document.getElementById('scoreBoard');
        const messageDiv = document.getElementById('message');
        const gameLogDiv = document.getElementById('gameLog'); 

        // éŠæˆ²å¸¸é‡
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;
        const PLAYER_RADIUS = 12;
        const BALL_RADIUS = 8;
        const GOAL_WIDTH = 10;
        const GOAL_HEIGHT = 120;
        const FRICTION_PLAYER = 0.98;
        const FRICTION_BALL = 0.99;
        const KICK_POWER_MULTIPLIER = 0.15;
        const MAX_KICK_DISTANCE = 150;

        // æ’æ­»æ©Ÿåˆ¶å¸¸é‡
        const KILL_CHANCE_BASE = 0.05; // åŸºç¤ã€Œæ’æ­»ã€æ©Ÿç‡ (5%)
        const KILL_CHANCE_SPEED_FACTOR = 0.025; // æ¯å–®ä½é€Ÿåº¦å¢åŠ çš„æ©Ÿç‡ä¿‚æ•¸
        const KILL_CHANCE_MIN_SPEED = 3; // è‡³å°‘è¦é”åˆ°æ­¤ç›¸å°é€Ÿåº¦å·®æ‰æœ‰æ©Ÿç‡è¢«æ’æ­»
        const INITIAL_PLAYER_COUNT = 20; // åˆå§‹ç¸½äººæ•¸ (10è— + 10ç´…)

        // éŠæˆ²ç‹€æ…‹ç‰©ä»¶
        let game = {
            score: { blue: 0, red: 0 },
            mouse: { x: 0, y: 0, down: false, startX: 0, startY: 0 },
            selectedPlayer: null,
            players: [],
            ball: null,
            turn: 'blue',
            running: true
        };
        
        // ------------------ Log ç´€éŒ„åŠŸèƒ½ ------------------
        function logMessage(text, type = 'info') {
            const entry = document.createElement('div');
            entry.classList.add('log-entry');
            entry.classList.add(`log-${type}`);
            entry.textContent = text;
            gameLogDiv.prepend(entry); 

            while (gameLogDiv.children.length > 50) {
                gameLogDiv.removeChild(gameLogDiv.lastChild);
            }
        }

        // ------------------ Player é¡åˆ¥ & Ball ç‰©ä»¶ (èˆ‡å‰ä¸€å€‹ç‰ˆæœ¬ç›¸åŒ) ------------------
        class Player {
            constructor(id, x, y, team, color) {
                this.id = id;
                this.initialX = x;
                this.initialY = y;
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.team = team;
                this.color = color;
                this.radius = PLAYER_RADIUS;
                this.mass = 1;
                this.isAlive = true;
            }

            update() {
                if (!this.isAlive) return;
                this.vx *= FRICTION_PLAYER;
                this.vy *= FRICTION_PLAYER;
                this.x += this.vx;
                this.y += this.vy;
                if (this.x - this.radius < 0 || this.x + this.radius > WIDTH) {
                    this.vx *= -1;
                    this.x = Math.max(this.radius, Math.min(WIDTH - this.radius, this.x));
                }
                if (this.y - this.radius < 0 || this.y + this.radius > HEIGHT) {
                    this.vy *= -1;
                    this.y = Math.max(this.radius, Math.min(HEIGHT - this.radius, this.y));
                }
            }

            draw() {
                if (!this.isAlive) return;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = '10px Arial';
                ctx.fillText(this.id, this.x, this.y);
            }
        }
        game.ball = {
            x: WIDTH / 2,
            y: HEIGHT / 2,
            vx: 0,
            vy: 0,
            radius: BALL_RADIUS,
            color: 'white',
            mass: 0.5,
            update: function() {
                this.vx *= FRICTION_BALL;
                this.vy *= FRICTION_BALL;
                this.x += this.vx;
                this.y += this.vy;
            },
            draw: function() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        };

        // ------------------ åˆå§‹åŒ–èˆ‡ä½ˆå±€ (èˆ‡å‰ä¸€å€‹ç‰ˆæœ¬ç›¸åŒ) ------------------
        function getInitialPositions() {
            const bluePositions = [
                {x: WIDTH / 10, y: HEIGHT / 2}, 
                {x: WIDTH / 6, y: HEIGHT * 0.15}, {x: WIDTH / 6, y: HEIGHT * 0.85}, 
                {x: WIDTH / 4, y: HEIGHT * 0.3}, {x: WIDTH / 4, y: HEIGHT * 0.7}, 
                {x: WIDTH / 3, y: HEIGHT * 0.1}, {x: WIDTH / 3, y: HEIGHT * 0.9}, 
                {x: WIDTH * 0.4, y: HEIGHT * 0.4}, {x: WIDTH * 0.4, y: HEIGHT * 0.6}, 
                {x: WIDTH * 0.45, y: HEIGHT / 2} 
            ];
            const redPositions = [
                {x: WIDTH * 0.9, y: HEIGHT / 2}, 
                {x: WIDTH * 5 / 6, y: HEIGHT * 0.15}, {x: WIDTH * 5 / 6, y: HEIGHT * 0.85}, 
                {x: WIDTH * 3 / 4, y: HEIGHT * 0.3}, {x: WIDTH * 3 / 4, y: HEIGHT * 0.7}, 
                {x: WIDTH * 2 / 3, y: HEIGHT * 0.1}, {x: WIDTH * 2 / 3, y: HEIGHT * 0.9}, 
                {x: WIDTH * 0.6, y: HEIGHT * 0.4}, {x: WIDTH * 0.6, y: HEIGHT * 0.6}, 
                {x: WIDTH * 0.55, y: HEIGHT / 2} 
            ];
            return { bluePositions, redPositions };
        }

        function initPlayers() {
            game.players = [];
            const { bluePositions, redPositions } = getInitialPositions();

            bluePositions.forEach((pos, i) => {
                game.players.push(new Player(`B${i + 1}`, pos.x, pos.y, 'blue', 'blue'));
            });

            redPositions.forEach((pos, i) => {
                game.players.push(new Player(`R${i + 1}`, pos.x, pos.y, 'red', 'red'));
            });
            logMessage(`éŠæˆ²é–‹å§‹! è—éšŠ(${game.players.length/2}äºº) vs ç´…éšŠ(${game.players.length/2}äºº)`, 'info');
        }
        
        // ------------------ ç‰©ç†èˆ‡ç¢°æ’ (é‡é»ä¿®æ”¹å€åŸŸ) ------------------

        function updatePhysics() {
            const activePlayers = game.players.filter(p => p.isAlive);
            activePlayers.forEach(p => p.update());
            game.ball.update();
            activePlayers.forEach(p => checkPlayerBallCollision(p, game.ball));
            for (let i = 0; i < activePlayers.length; i++) {
                for (let j = i + 1; j < activePlayers.length; j++) {
                    checkPlayerPlayerCollision(activePlayers[i], activePlayers[j]);
                }
            }
            checkBallBounds(game.ball);
            checkTurnEnd();
        }

        function checkPlayerBallCollision(p, ball) {
            // (èˆ‡å‰ä¸€å€‹ç‰ˆæœ¬ç›¸åŒ)
            const dx = ball.x - p.x;
            const dy = ball.y - p.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const minDistance = p.radius + ball.radius;

            if (distance < minDistance) {
                const angle = Math.atan2(dy, dx);
                const overlap = minDistance - distance;

                p.x -= overlap * Math.cos(angle) * (ball.mass / (p.mass + ball.mass));
                p.y -= overlap * Math.sin(angle) * (ball.mass / (p.mass + ball.mass));
                ball.x += overlap * Math.cos(angle) * (p.mass / (p.mass + ball.mass));
                ball.y += overlap * Math.sin(angle) * (p.mass / (p.mass + ball.mass));

                const totalMass = p.mass + ball.mass;
                const dvx = p.vx - ball.vx;
                const dvy = p.vy - ball.vy;
                const impulse = (dx * dvx + dy * dvy) / (distance * distance);

                const impulseX = impulse * dx;
                const impulseY = impulse * dy;

                p.vx -= impulseX * ball.mass / totalMass;
                p.vy -= impulseY * ball.mass / totalMass;
                ball.vx += impulseX * p.mass / totalMass;
                ball.vy += impulseY * p.mass / totalMass;
            }
        }

        function checkPlayerPlayerCollision(p1, p2) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const minDistance = p1.radius + p2.radius;

            if (distance < minDistance) {
                // --- 1. ç‰©ç†ç¢°æ’è™•ç† (ä¿ç•™) ---
                const angle = Math.atan2(dy, dx);
                const overlap = minDistance - distance;
                const totalMass = p1.mass + p2.mass;
                
                // ä½ç½®ä¿®æ­£
                p1.x -= overlap * Math.cos(angle) * (p2.mass / totalMass);
                p1.y -= overlap * Math.sin(angle) * (p2.mass / totalMass);
                p2.x += overlap * Math.cos(angle) * (p1.mass / totalMass);
                p2.y += overlap * Math.sin(angle) * (p1.mass / totalMass);

                // é€Ÿåº¦äº¤æ›
                const dvx = p1.vx - p2.vx;
                const dvy = p1.vy - p2.vy;
                const impulse = (dx * dvx + dy * dvy) / (distance * distance);

                const impulseX = impulse * dx;
                const impulseY = impulse * dy;

                p1.vx -= impulseX * p2.mass / totalMass;
                p1.vy -= impulseY * p2.mass / totalMass;
                p2.vx += impulseX * p1.mass / totalMass;
                p2.vy += impulseY * p1.mass / totalMass;

                // --- 2. æ’æ­»æ©Ÿç‡é‚è¼¯ (æ ¸å¿ƒä¿®æ”¹) ---

                // **ã€ä¿®æ”¹ 1ã€‘åŒéšŠæ’æ“Šå®‰å…¨æª¢æŸ¥**
                if (p1.team === p2.team) {
                    // åŒéšŠçƒå“¡åªé€²è¡Œç‰©ç†ç¢°æ’ï¼Œä¸æœƒè¢«æ’æ­»
                    return;
                }
                
                // è¨ˆç®—æ’æ“Šå¾Œçš„ç›¸å°é€Ÿåº¦ï¼ˆå³è¡é‡çš„å¤§å°ï¼‰
                const relativeSpeed = Math.sqrt(impulseX**2 + impulseY**2) * 50; 
                
                if (relativeSpeed > KILL_CHANCE_MIN_SPEED) {
                    // **ã€ä¿®æ”¹ 2ã€‘æ©Ÿç‡å—å­˜æ´»äººæ•¸å½±éŸ¿**
                    const activeCount = game.players.filter(p => p.isAlive).length;
                    const countFactor = activeCount / INITIAL_PLAYER_COUNT; // ä¾‹å¦‚ï¼š10äºº/20äºº = 0.5

                    let extraChance = (relativeSpeed - KILL_CHANCE_MIN_SPEED) * KILL_CHANCE_SPEED_FACTOR;
                    
                    // å°‡æ©Ÿç‡ä¹˜ä»¥äººæ•¸å› å­ (äººæ•¸è¶Šå°‘ï¼Œé€™å€‹å› å­è¶Šä½ï¼Œç¸½æ©Ÿç‡è¶Šä½)
                    let killChance = (KILL_CHANCE_BASE + extraChance) * countFactor; 
                    
                    killChance = Math.min(killChance, 0.7); // æœ€é«˜ 70% æ©Ÿç‡

                    const randomValue = Math.random();

                    if (randomValue < killChance) {
                        const p1ImpactSpeed = Math.sqrt(p1.vx**2 + p1.vy**2);
                        const p2ImpactSpeed = Math.sqrt(p2.vx**2 + p2.vy**2);
                        
                        let killedPlayer = null;
                        let killerPlayer = null;
                        
                        // èª°æ…¢èª°å‡ºå±€
                        if (p1ImpactSpeed < p2ImpactSpeed) {
                            killedPlayer = p1;
                            killerPlayer = p2;
                        } else {
                            killedPlayer = p2;
                            killerPlayer = p1;
                        }
                        
                        killedPlayer.isAlive = false;
                        killedPlayer.vx = 0;
                        killedPlayer.vy = 0;
                        
                        const chancePercent = Math.round(killChance * 100);

                        messageDiv.textContent = `ğŸš¨ ${killedPlayer.color}éšŠçƒå“¡ ${killedPlayer.id} è¢«ã€Œæ’å‡ºå±€ã€! (å¯¦éš›æ©Ÿç‡: ${chancePercent}%) ğŸš¨`;
                        logMessage(`âŒ ${killerPlayer.color}éšŠ ${killerPlayer.id} æ’æ­» ${killedPlayer.color}éšŠ ${killedPlayer.id}ï¼(å¯¦éš›æ©Ÿç‡: ${chancePercent}%)`, 'kill');
                    }
                }
            }
        }

        // ------------------ éŠæˆ²æµç¨‹æ§åˆ¶ (èˆ‡å‰ä¸€å€‹ç‰ˆæœ¬ç›¸åŒ) ------------------

        function isMoving() {
            const activePlayers = game.players.filter(p => p.isAlive);
            const ballMoving = (Math.abs(game.ball.vx) > 0.1 || Math.abs(game.ball.vy) > 0.1);
            const playerMoving = activePlayers.some(p => Math.abs(p.vx) > 0.1 || Math.abs(p.vy) > 0.1);
            return ballMoving || playerMoving;
        }

        function getPlayerCounts() {
            return {
                blueCount: game.players.filter(p => p.team === 'blue' && p.isAlive).length,
                redCount: game.players.filter(p => p.team === 'red' && p.isAlive).length
            };
        }

        function checkTurnEnd() {
            const { blueCount, redCount } = getPlayerCounts();
            
            if (blueCount === 0 && redCount === 0) {
                 handleGameOver('å¹³æ‰‹');
                 return;
            } else if (blueCount === 0) {
                handleGameOver('red');
                return;
            } else if (redCount === 0) {
                handleGameOver('blue');
                return;
            }

            if (isMoving()) {
                // messageDiv.textContent = `å›åˆé€²è¡Œä¸­... | è—éšŠ: ${blueCount} äºº | ç´…éšŠ: ${redCount} äºº`;
                game.selectedPlayer = null;
            } else {
                messageDiv.textContent = `è«‹é»æ“Šå ´ä¸Šå­˜æ´»çƒå“¡é€²è¡Œç™¼å°„ (${game.turn === 'blue' ? 'è—éšŠ' : 'ç´…éšŠ'}å›åˆ) | è—éšŠ: ${blueCount} äºº | ç´…éšŠ: ${redCount} äºº`;
                
                if (game.turn === 'red') {
                    setTimeout(aiShoot, 1000); 
                }
            }
        }

        function handleGoal(scoringTeam) {
            if (game.running) {
                if (scoringTeam === 'blue') {
                    game.score.blue++;
                } else {
                    game.score.red++;
                }

                scoreBoard.textContent = `âš½ è—éšŠ: ${game.score.blue} - ç´…éšŠ: ${game.score.red} âš½`;
                messageDiv.textContent = `${scoringTeam === 'blue' ? 'è—éšŠ' : 'ç´…éšŠ'}å¾—åˆ†ï¼å›åˆé‡ç½®...`;
                logMessage(`ğŸ¥… ${scoringTeam === 'blue' ? 'è—éšŠ' : 'ç´…éšŠ'}å¾—åˆ†ï¼æ¯”åˆ† ${game.score.blue}:${game.score.red}`, 'goal');
                game.running = false; 

                setTimeout(() => {
                    resetRound(scoringTeam);
                }, 2000);
            }
        }

        function handleGameOver(winnerTeam) {
            game.running = false;
            scoreBoard.textContent = `ğŸ æœ€çµ‚æ¯”åˆ† è—éšŠ: ${game.score.blue} - ç´…éšŠ: ${game.score.red} ğŸ`;
            
            let message = '';
            if (winnerTeam === 'å¹³æ‰‹') {
                message = 'ğŸ† æ¯”è³½çµæŸ! æ‰€æœ‰çƒå“¡å‡ºå±€ï¼Œå¹³æ‰‹ã€‚ ğŸ†';
            } else {
                message = `ğŸ† æ¯”è³½çµæŸ! ${winnerTeam === 'blue' ? 'è—éšŠ' : 'ç´…éšŠ'} ç²å‹ï¼ğŸ†`;
            }

            messageDiv.textContent = message + ' (è«‹åˆ·æ–°é é¢é‡æ–°é–‹å§‹)';
            logMessage(message, 'info'); 
        }

        function resetRound(startingTeam) {
            game.ball.x = WIDTH / 2;
            game.ball.y = HEIGHT / 2;
            game.ball.vx = 0;
            game.ball.vy = 0;

            game.players.filter(p => p.isAlive).forEach(p => { 
                p.x = p.initialX; 
                p.y = p.initialY; 
                p.vx = 0; 
                p.vy = 0; 
            });
            
            game.turn = startingTeam; 
            game.running = true;
            logMessage(`æ–°å›åˆé–‹å§‹ã€‚ç”± ${startingTeam === 'blue' ? 'è—éšŠ' : 'ç´…éšŠ'} é–‹çƒã€‚`, 'info');

            if (game.turn === 'red') {
                setTimeout(aiShoot, 500);
            }
        }
        
        // ------------------ AI é‚è¼¯ (ç´…éšŠ) (èˆ‡å‰ä¸€å€‹ç‰ˆæœ¬ç›¸åŒ) ------------------
        
        function aiShoot() {
            if (game.turn !== 'red' || isMoving()) return;
            
            const activeRedPlayers = game.players.filter(p => p.team === 'red' && p.isAlive);
            if (activeRedPlayers.length === 0) {
                game.turn = 'blue';
                return;
            }

            let closestPlayer = activeRedPlayers.reduce((closest, p) => {
                const dist = Math.sqrt((p.x - game.ball.x)**2 + (p.y - game.ball.y)**2);
                return dist < closest.dist ? { player: p, dist: dist } : closest;
            }, { player: null, dist: Infinity }).player;
            
            if (closestPlayer) {
                const targetX = GOAL_WIDTH + 10; 
                const targetY = HEIGHT / 2;
                
                const dxTarget = targetX - closestPlayer.x;
                const dyTarget = targetY - closestPlayer.y;

                const shootVectorX = - (dxTarget * 0.35); 
                const shootVectorY = - (dyTarget * 0.35);
                
                const distance = Math.sqrt(shootVectorX**2 + shootVectorY**2);
                const power = Math.min(distance, MAX_KICK_DISTANCE * 0.8); 
                
                const normalizedX = shootVectorX / distance;
                const normalizedY = shootVectorY / distance;

                const kickVx = -normalizedX * power * KICK_POWER_MULTIPLIER;
                const kickVy = -normalizedY * power * KICK_POWER_MULTIPLIER;

                closestPlayer.vx = kickVx;
                closestPlayer.vy = kickVy;
                
                game.turn = 'blue';
                logMessage(`ç´…éšŠ ${closestPlayer.id} ç™¼å°„ï¼`, 'info');
            }
        }

        // ------------------ ç¹ªåœ–å‡½æ•¸ (èˆ‡å‰ä¸€å€‹ç‰ˆæœ¬ç›¸åŒ) ------------------

        function drawField() {
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(WIDTH / 2, 0); ctx.lineTo(WIDTH / 2, HEIGHT); ctx.stroke();
            ctx.beginPath();
            ctx.arc(WIDTH / 2, HEIGHT / 2, 50, 0, Math.PI * 2); ctx.stroke();

            ctx.fillStyle = 'yellow';
            ctx.fillRect(0, HEIGHT / 2 - GOAL_HEIGHT / 2, GOAL_WIDTH, GOAL_HEIGHT);
            ctx.fillRect(WIDTH - GOAL_WIDTH, HEIGHT / 2 - GOAL_HEIGHT / 2, GOAL_WIDTH, GOAL_HEIGHT);
        }
        
        function drawShootIndicator() {
            if (!game.selectedPlayer || !game.mouse.down) return;

            const p = game.selectedPlayer;
            const mouseX = game.mouse.x;
            const mouseY = game.mouse.y;

            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(mouseX, mouseY);
            ctx.stroke();
            ctx.setLineDash([]);

            const dx = p.x - mouseX;
            const dy = p.y - mouseY;
            const distance = Math.min(Math.sqrt(dx * dx + dy * dy), MAX_KICK_DISTANCE);
            
            const normalizedX = dx / distance;
            const normalizedY = dy / distance;

            const predictedVx = normalizedX * distance * KICK_POWER_MULTIPLIER;
            const predictedVy = normalizedY * distance * KICK_POWER_MULTIPLIER;

            const endX = p.x + predictedVx * 5; 
            const endY = p.y + predictedVy * 5; 
            
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
            ctx.lineWidth = 5;
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(endX, endY);
            ctx.stroke();
        }

        // ------------------ äº‹ä»¶èˆ‡å¾ªç’° (èˆ‡å‰ä¸€å€‹ç‰ˆæœ¬ç›¸åŒ) ------------------

        canvas.addEventListener('mousedown', (e) => {
            if (isMoving() || game.turn === 'red' || !game.running) return; 

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const clickedPlayer = game.players.find(p => 
                p.isAlive && 
                p.team === game.turn && 
                Math.sqrt((p.x - mouseX)**2 + (p.y - mouseY)**2) < p.radius
            );

            if (clickedPlayer) {
                game.mouse.down = true;
                game.mouse.startX = mouseX;
                game.mouse.startY = mouseY;
                game.selectedPlayer = clickedPlayer;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            game.mouse.x = e.clientX - rect.left;
            game.mouse.y = e.clientY - rect.top;
        });

        canvas.addEventListener('mouseup', (e) => {
            if (game.mouse.down && game.selectedPlayer) {
                const p = game.selectedPlayer;
                const dragX = game.mouse.x - game.mouse.startX;
                const dragY = game.mouse.y - game.mouse.startY;
                
                const distance = Math.min(Math.sqrt(dragX * dragX + dragY * dragY), MAX_KICK_DISTANCE);
                const normalizedDragX = dragX / distance;
                const normalizedDragY = dragY / distance;

                const kickVx = -normalizedDragX * distance * KICK_POWER_MULTIPLIER;
                const kickVy = -normalizedDragY * distance * KICK_POWER_MULTIPLIER;

                p.vx = kickVx;
                p.vy = kickVy;

                logMessage(`è—éšŠ ${p.id} ç™¼å°„ï¼`, 'info');

                game.mouse.down = false;
                game.selectedPlayer = null;
                game.turn = (game.turn === 'blue' ? 'red' : 'blue');
            }
        });

        // ------------------ é‚Šç•Œæª¢æŸ¥èˆ‡çƒé–€ (èˆ‡å‰ä¸€å€‹ç‰ˆæœ¬ç›¸åŒ) ------------------
        function checkBallBounds(ball) {
            const inGoalY = ball.y >= HEIGHT / 2 - GOAL_HEIGHT / 2 && ball.y <= HEIGHT / 2 + GOAL_HEIGHT / 2;

            if (ball.x - ball.radius <= 0) {
                 if (inGoalY) {
                     handleGoal('red');
                     return;
                 } else {
                     ball.vx *= -1;
                     ball.x = ball.radius;
                 }
            } 
            else if (ball.x + ball.radius >= WIDTH) {
                 if (inGoalY) {
                     handleGoal('blue');
                     return;
                 } else {
                     ball.vx *= -1;
                     ball.x = WIDTH - ball.radius;
                 }
            }
            if (ball.y - ball.radius < 0 || ball.y + ball.radius > HEIGHT) {
                ball.vy *= -1;
                ball.y = Math.max(ball.radius, Math.min(HEIGHT - ball.radius, ball.y));
            }
        }


        function gameLoop() {
            if (!game.running) {
                requestAnimationFrame(gameLoop);
                return;
            }

            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            drawField();
            drawShootIndicator();

            updatePhysics();
            
            game.players.forEach(p => p.draw());
            game.ball.draw();

            requestAnimationFrame(gameLoop);
        }

        // å•Ÿå‹•éŠæˆ²
        initPlayers();
        gameLoop();
        logMessage("éŠæˆ²è¼‰å…¥å®Œæˆï¼Œè—éšŠå…ˆç™¼å°„ã€‚", 'info');
    </script>
</body>
</html>